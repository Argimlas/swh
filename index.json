[{"content":"This post features the instruction for my bar terminals.\nNote: You can also find all files for the project here.\nIntroduction # With this instruction, I will show you how to build yourself (bar-) terminals, that use radio signals to send each other predefined messages.\nThe terminal allows you to select a message and send it to a selected other terminal and displays receive messages on an oled. If a message is received a LED turns on to indicate the received message.\nThe messages are sent via a radio signal and the terminals are implemented as a really simplified mesh-network so each terminal receives the message and if the message is not meant for the terminal it forwards the message. This also allows to bridge longer distances than the radio signal can reach.\nIf you want to read more about the project you can check out this post.\nEverything you need # For 3 bar-terminals you need the following:\nParts # 3 x HC-12 radio module: Amazon 3 x Arduino Nano: Amazon 3 x 128x64 oled: Amazon 3 x EC12 rotary encoder: Amazon 3 x Red LEDs (5mm) 3 x 100 µF Capacitor 3 x 220 Ω Resistor (for LED - pulldown) 9 x 10 kΩ Resistor (for Rotary encoder - pulldown) Hardware # filament for your 3D-printer Solder (and if needed Flux) Wires shrink tubing hot-glue-sticks 3 x pcb like those: Amazon 3 x 9V Battery 3 x Battery clips 9V like those: Amazon Tools # 3D Printer Soldering Station/Iron If needed: helping hands for soldering or a vise as misused helping hands :D Hot-glue-gun Wire stripper Pliers Saw (Handsaw, Bandsaw or similar) Soldering # In the following image, you can see how everything is supposed to be wired up. I always used 70mm long wires for soldering.\nsoldering diagram Because the space is limited you need to cut the pcbs to the desired size of 18x11 holes.\nTo connect more holes I used a short wire and soldered it to each hole and the pin of the Arduino.\ncutted pcb with connection of holes 5V and gnd line from top As you can see I only soldered the pins of the Arduino, that I needed. On the left picture on the left-hand side you can see the gnd and 5V line from the bottom. The next step would be to connect the gnd-arduino-pin with the gnd line and the 5V pin with the 5V line.\ngnd connection 5V-connection VIN and gnd-wire for the external power source\nblue: VIN-wire, black: gnd-wire If you directly solder the 9V Battery clips onto the pcb it would be black on gnd and red on VIN.\nNext you should solder the radio-module.\nSolder the 100 µF Capacitor onto the module. ⚠️ be careful so that the white side of the capacitor is connected to the gnd pin of the radio-module\nNow solder all 4 wires to the radio-module.\nIn the last step you solder the wires from the radio module to your pcb, start with gnd then 5V and then the two data wires.\nradio-module with capacitor After the radio module continue with soldering the oled-screen. Again, first solder the wires to the screen and then to the pcb. On the pcb start with gnd, then 5V, then the data wires.\nNow the LED follows. First solder the 220 Ω Resistor onto the short leg (cut side) of the LED. This site also goes onto your gnd line on the pcb. After that solder the other leg of the LED onto the data pin.\nNext is the rotary encoder:\nFirst solder all the wires onto the rotary encoder and then the two gnd wires onto the gnd-line on the pcb.\nAfter that, solder the three 10 kΩ Resistors onto the 5V-line and then onto the three data pins. To prevent short circuits use shrink tubing around the resistors and only leave a small part of the wire unprotected.\n10 kΩ Resistors with shrink tubing To finish solder the data wires onto the pcb.\nCongratulations you finished soldering everything! It should look somewhat like this:\nleft front right Code # I used visual-studio-code with the platform.io extension to write my program. In the zip folder, you can download, you can also find a complete platform.io project.\nI used the SSD1306Ascii library which is pretty resource-saving, so the ram of the nano is only 50% full.\nThe code is completely commented and should be self-explaining. The basic thoughts behind the menu-system are bools to check if screens are active or not and the cursor just overwrites a defined position on the screen if the rotary encoder is turned in either direction.\nThe terminal just sends a string with 4 numbers which the other terminals then evaluate.\nTo use this code for more than one terminal you just have to change lines 51 and 52 in the code.\nString fromBar = \u0026#34;1\u0026#34;; //change this to the according terminal number String barName = \u0026#34;Caipibar (Bar 1)\u0026#34;; //change this to the according The whole Arduino-sketch:\n#include \u0026lt;Arduino.h\u0026gt; //only for platform.io #include \u0026lt;Wire.h\u0026gt; #include \u0026#34;SSD1306Ascii.h\u0026#34; #include \u0026#34;SSD1306AsciiWire.h\u0026#34; #include \u0026lt;SoftwareSerial.h\u0026gt; //BAR/Terminal 1 !!! // Header: to whom?, from who, message, forward-bit #define I2C_ADDRESS 0x3C // Rotary Encoder Inputs #define CLK 2 #define DT 3 #define SW 4 //LED #define LED 7 //HC12 SoftwareSerial hc12(10,11); //OLED SSD1306AsciiWire oled; //Encoder int counter = 0; int counterTemp = 0; int currentStateCLK; int lastStateCLK; String currentDir =\u0026#34;\u0026#34;; //Button unsigned long lastButtonPress = 0; int isPressed = false; //Bools for screens bool startScreenBool; bool messageScreenBool; bool barScreenBool; //Bools for Cursor bool cursorBackBool; bool cursor4Bool; bool cursor5Bool; bool cursor6Bool; //Variables for send message (header) String toBar; String fromBar = \u0026#34;1\u0026#34;; //change this to the according terminal number String barName = \u0026#34;Caipibar (Bar 1)\u0026#34;; //change this to the according terminal number and name String toMessage; String forwardBit = \u0026#34;0\u0026#34;; //Variables for recieved Message String recievedPayload; String recievedForwardBit = \u0026#34;1\u0026#34;; bool recievedMessage; //functions (because of platform.io) void startScreen(); void messageScreen(); void barScreen(); void menueMessageScreen(); void menueBarScreen(); void setCursorBack(); void setCursor4(); void setCursor5(); void setCursor6(); void clearCursors(); void readRecievedPayload(String recievedPayload); void printRecievedMessage(int fromBar, int message); void sendMessage(); //SetupFunction void setup() { //Start radio-module hc12.begin(9600); //Set LED pin as output pinMode(LED, OUTPUT); // Set encoder pins as inputs pinMode(CLK,INPUT); pinMode(DT,INPUT); pinMode(SW, INPUT_PULLUP); // Setup Serial Monitor Serial.begin(9600); // Read the initial state of CLK lastStateCLK = digitalRead(CLK); //Setup oled-screen Wire.begin(); Wire.setClock(400000L); oled.begin(\u0026amp;SH1106_128x64, I2C_ADDRESS); oled.setFont(System5x7); startScreen(); } //loop function void loop() { //----------------handle recieved messages-----------------------| if (startScreenBool) { //if on startscreen if(hc12.available()) { recievedPayload = hc12.readString(); //read the recieved message // split the message int msgToBar = recievedPayload.substring(0, 1).toInt(); int msgFromBar = recievedPayload.substring(1, 2).toInt(); int msg = recievedPayload.substring(2, 3).toInt(); int msgForwardBit = recievedPayload.substring(3).toInt(); if (msgToBar == fromBar.toInt()) { //checks if message is for this terminal digitalWrite(LED, HIGH); recievedMessage = true; readRecievedPayload(recievedPayload); } else if(msgToBar == toBar.toInt() \u0026amp;\u0026amp; msgFromBar == fromBar.toInt() \u0026amp;\u0026amp; msg == toMessage.toInt()) { //checks if its the own message Serial.println(\u0026#34;Meine eigene nachricht\u0026#34;); } else if(msgForwardBit == recievedForwardBit.toInt()) { //checks if message already forwarded recievedForwardBit = \u0026#34;1\u0026#34;; Serial.println(\u0026#34;Nachricht schon mal forwarded\u0026#34;); } else { //forward message recievedForwardBit = msgForwardBit; hc12.print(recievedPayload); Serial.println(\u0026#34;Message forwarded\u0026#34;); } } } //---------------------------------encoder---------------------------| // Read the current state of CLK currentStateCLK = digitalRead(CLK); // If last and current state of CLK are different, then pulse occurred // React to only 1 state change to avoid double count if (currentStateCLK != lastStateCLK \u0026amp;\u0026amp; currentStateCLK == 1){ // If the DT state is different than the CLK state then // the encoder is rotating CCW so decrement if (digitalRead(DT) != currentStateCLK) { counter --; currentDir =\u0026#34;CCW\u0026#34;; if (messageScreenBool || barScreenBool) { //if either on message-selection-screen or on bar-selection-screen if (!cursorBackBool \u0026amp;\u0026amp; !cursor4Bool \u0026amp;\u0026amp; !cursor5Bool \u0026amp;\u0026amp; !cursor6Bool) setCursorBack(); //checks if no cursor is set else if (cursorBackBool) setCursor4(); else if (cursor4Bool) setCursor5(); else if (cursor5Bool) setCursor6(); else if (cursor6Bool) setCursorBack(); } } else { // Encoder is rotating CW so increment counter ++; currentDir =\u0026#34;CW\u0026#34;; if (messageScreenBool || barScreenBool) { //if either on message-selection-screen or on bar-selection-screen if (!cursorBackBool \u0026amp;\u0026amp; !cursor4Bool \u0026amp;\u0026amp; !cursor5Bool \u0026amp;\u0026amp; !cursor6Bool) setCursorBack(); //checks if no cursor is set else if (cursorBackBool) setCursor6(); else if (cursor6Bool) setCursor5(); else if (cursor5Bool) setCursor4(); else if (cursor4Bool) setCursorBack(); } } Serial.print(\u0026#34;Direction: \u0026#34;); Serial.print(currentDir); Serial.print(\u0026#34; | Counter: \u0026#34;); Serial.println(counter); } // Remember last CLK state lastStateCLK = currentStateCLK; //-------------------Button--------------------| // Read the button state int btnState = digitalRead(SW); //If we detect LOW signal, button is pressed if (btnState == LOW) { //if 50ms have passed since last LOW pulse, it means that the //button has been pressed, released and pressed again if (millis() - lastButtonPress \u0026gt; 50) { Serial.println(\u0026#34;Button pressed!\u0026#34;); if (recievedMessage == true) { //turns of LED if message was read after recieved and removes message from startscreen startScreen(); } else if (!messageScreenBool \u0026amp;\u0026amp; !barScreenBool \u0026amp;\u0026amp; recievedMessage == false) messageScreen(); //switches to message-selection-screen if messageScreen AND barScreen not active AND no message recieved //message-selection-screen, decides when to switch to bar screen if (cursorBackBool \u0026amp;\u0026amp; !barScreenBool) { //switches from message-selection-screen to startscreen startScreen(); } else if (cursor4Bool \u0026amp;\u0026amp; !barScreenBool) { //switches to barScreen if cursor on msg1 and NOT in barScreen barScreen(); toMessage = \u0026#34;1\u0026#34;; } else if (cursor5Bool \u0026amp;\u0026amp; !barScreenBool) { barScreen(); toMessage = \u0026#34;2\u0026#34;; } else if (cursor6Bool \u0026amp;\u0026amp; !barScreenBool) { barScreen(); toMessage = \u0026#34;3\u0026#34;; } //bar-seleciton screen, decides when to switch back to startscreen over the sendMessage function if (cursorBackBool \u0026amp;\u0026amp; !messageScreenBool) { //switches from bar-seleciton screen to message-selection-screen messageScreen(); } else if (cursor4Bool \u0026amp;\u0026amp; !messageScreenBool) { toBar = \u0026#34;1\u0026#34;; sendMessage(); } else if (cursor5Bool \u0026amp;\u0026amp; !messageScreenBool) { toBar = \u0026#34;2\u0026#34;; sendMessage(); } else if (cursor6Bool \u0026amp;\u0026amp; !messageScreenBool) { toBar = \u0026#34;3\u0026#34;; sendMessage(); } } // Remember last button press event lastButtonPress = millis(); } // Put in a slight delay to help debounce the reading delay(1); } //\u0026lt;---------Screen functions----------------\u0026gt; void startScreen() { startScreenBool = true; messageScreenBool = false; barScreenBool = false; digitalWrite(LED, LOW); recievedMessage = false; clearCursors(); oled.clear(); oled.setRow(0); oled.println(barName); oled.setRow(2); oled.println(\u0026#34;Press button to send\u0026#34;); oled.setRow(3); oled.println(\u0026#34;a message!\u0026#34;); oled.setRow(4); oled.println(\u0026#34; \u0026#34;); oled.setRow(5); oled.println(\u0026#34; \u0026#34;); oled.setRow(6); oled.println(\u0026#34; \u0026#34;); oled.setRow(7); oled.println(\u0026#34; \u0026#34;); } void messageScreen() { startScreenBool = false; messageScreenBool = true; barScreenBool = false; digitalWrite(LED, LOW); recievedMessage = false; clearCursors(); oled.clear(); menueMessageScreen(); } void barScreen() { startScreenBool = false; messageScreenBool = false; barScreenBool = true; digitalWrite(LED, LOW); recievedMessage = false; clearCursors(); oled.clear(); menueBarScreen(); } //\u0026lt;---------Menue functions--------------\u0026gt; void menueMessageScreen() { //Heading oled.println(\u0026#34;Choose a message!\u0026#34;); //Back Button oled.setRow(2); oled.println(\u0026#34; Back to start\u0026#34;); //Messages oled.setRow(4); oled.println(\u0026#34; need helpers\u0026#34;); oled.setRow(5); oled.println(\u0026#34; need glasses\u0026#34;); oled.setRow(6); oled.println(\u0026#34; need change\u0026#34;); //Cursor } void menueBarScreen() { //Heading oled.println(\u0026#34;Choose a bar!\u0026#34;); //Back Button oled.setRow(2); oled.println(\u0026#34; Back to messages\u0026#34;); //Messages oled.setRow(4); oled.println(\u0026#34; Caipibar\u0026#34;); oled.setRow(5); oled.println(\u0026#34; Shotbar\u0026#34;); oled.setRow(6); oled.println(\u0026#34; Bierbar\u0026#34;); //Cursor } //\u0026lt;---------------other functions-------------------\u0026gt; void readRecievedPayload(String recievedPayload) { //splits the recieved message int fromBar = recievedPayload.substring(1,2).toInt(); int message = recievedPayload.substring(2,3).toInt(); printRecievedMessage(fromBar, message); } void printRecievedMessage(int fromBar, int message) { //prints the recieved message String FromBar; String Message; if (fromBar == 1) FromBar = \u0026#34;Caipibar \u0026#34;; else if (fromBar == 2) FromBar = \u0026#34;Shotbar \u0026#34;; else if (fromBar == 3) FromBar = \u0026#34;Bierbar \u0026#34;; if (message == 1) Message = \u0026#34;needs helpers!\u0026#34;; else if (message == 2) Message = \u0026#34;needs glasses!\u0026#34;; else if (message == 3) Message = \u0026#34;needs change.\u0026#34;; String printMessage = FromBar + Message; oled.setRow(5); oled.println(\u0026#34;Recieved a message:\u0026#34;); oled.setRow(6); oled.println(\u0026#34; \u0026#34;); oled.setRow(7); oled.println(printMessage); } void sendMessage() { //sends the Message, switches to startscreen and shows succesfull send String msg = toBar + fromBar + toMessage + forwardBit; hc12.print(msg); startScreen(); oled.setRow(5); oled.println(\u0026#34;Message send\u0026#34;); oled.setRow(6); oled.println(\u0026#34;succesfully!\u0026#34;); oled.setRow(7); oled.println(\u0026#34; \u0026#34;); } //\u0026lt;------------------Set Cursor Functions----------------\u0026gt; void setCursorBack() { cursorBackBool = true; oled.setRow(2); oled.setCol(0); oled.print(\u0026#34;\u0026lt;\u0026#34;); cursor4Bool = false; oled.setRow(4); oled.setCol(0); oled.print(\u0026#34; \u0026#34;); cursor5Bool = false; oled.setRow(5); oled.setCol(0); oled.println(\u0026#34; \u0026#34;); cursor6Bool = false; oled.setRow(6); oled.setCol(0); oled.println(\u0026#34; \u0026#34;); } void setCursor4() { cursorBackBool = false; oled.setRow(2); oled.setCol(0); oled.print(\u0026#34; \u0026#34;); cursor4Bool = true; oled.setRow(4); oled.setCol(0); oled.print(\u0026#34;\u0026gt;\u0026#34;); cursor5Bool = false; oled.setRow(5); oled.setCol(0); oled.println(\u0026#34; \u0026#34;); cursor6Bool = false; oled.setRow(6); oled.setCol(0); oled.println(\u0026#34; \u0026#34;); } void setCursor5() { cursorBackBool = false; oled.setRow(2); oled.setCol(0); oled.print(\u0026#34; \u0026#34;); cursor4Bool = false; oled.setRow(4); oled.setCol(0); oled.print(\u0026#34; \u0026#34;); cursor5Bool = true; oled.setRow(5); oled.setCol(0); oled.println(\u0026#34;\u0026gt;\u0026#34;); cursor6Bool = false; oled.setRow(6); oled.setCol(0); oled.println(\u0026#34; \u0026#34;); } void setCursor6() { cursorBackBool = false; oled.setRow(2); oled.setCol(0); oled.print(\u0026#34; \u0026#34;); cursor4Bool = false; oled.setRow(4); oled.setCol(0); oled.print(\u0026#34; \u0026#34;); cursor5Bool = false; oled.setRow(5); oled.setCol(0); oled.println(\u0026#34; \u0026#34;); cursor6Bool = true; oled.setRow(6); oled.setCol(0); oled.println(\u0026#34;\u0026gt;\u0026#34;); } void clearCursors() { cursorBackBool = false; cursor4Bool = false; cursor5Bool = false; cursor6Bool = false; } 3D-printing # Now you need to print the housing of the terminal. It consists of two parts, the box and the cover.\nThe measurements of my housing are made for a specific cash register we use at our uni-partys, if you want to fit the terminal into your cash register you probably have to take the measurements by yourself and design your box.\nFor printing you don\u0026rsquo;t need a support structure!\ncover # Top Bottom The cover has four openings as you can see in the \u0026ldquo;Top\u0026rdquo;-image:\nin the Back: small hole for the antenna right-hand side: hole for the LED in between those two holes: opening for the oled-screen in the middle of the picture: hole for the rotary encoder Some measurements so you don\u0026rsquo;t have to get them again:\nhole antenna: 2 mm diameter hole LED: 9 mm diameter hole rotary encoder: 11 mm diameter oled display size: 31 x 16 mm oled notch like seen in the \u0026ldquo;Bottom\u0026rdquo;-image: notch measurements Download coverV2.stl\nbox # box There is not much to say about the box.\nDownload box.stl\nAssembly # Basically, you just glue everything to the cover and put the cover on the box.\nStart with putting the rotary-encoder through the specified hole and fix it with the included screw\nattachment rotary encoder Radio-module\nNow follows the tricky party put the antenna of the radio module from the top through the specified hole of the cover and then solder the radio-module onto it from the bottom side of the cover.\nAfter that fix the radio module with hot-glue onto the cover.\nantenna glued radio-module Screen and LED\nNow fix the Screen and LED with hot glue onto the cover.\noled and LED fixed with hot-glue Finished cover\nThe cover should look like this now:\nbottom top Put the cover on the box After you glued everything to the cover you just need to add a 9V-Block as a power source, here a switch to cut the power would be useful, which unfortunately is not yet included.\nFinished! # Congratulations you finished the project!\nFinished terminal Again, here you can download everything you need for the project as a zip-file.\nLicense # This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\n","date":"22 July 2023","permalink":"/swh/posts/instruction-bar-terminals/","section":"Posts","summary":"This post features the instruction for my bar terminals.\nNote: You can also find all files for the project here.\nIntroduction # With this instruction, I will show you how to build yourself (bar-) terminals, that use radio signals to send each other predefined messages.","title":"Instruction Bar Terminals"},{"content":"","date":"22 July 2023","permalink":"/swh/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"On this site I will document the progress of my DIY-project in the subject \u0026ldquo;Sketching with Hardware\u0026rdquo; at Institute of Media Informatics at Ulm University.\n","date":"22 July 2023","permalink":"/swh/","section":"Sketching with Hardware","summary":"On this site I will document the progress of my DIY-project in the subject \u0026ldquo;Sketching with Hardware\u0026rdquo; at Institute of Media Informatics at Ulm University.","title":"Sketching with Hardware"},{"content":" Project pitch # We started the second semester with a presentation about the pitch of the project we planned to tackle for the second semester.\nThe Problem I wanted to solve is communication between bars and finances at Uni-Partys.\nCurrently, DECTs are used to communicate on uni-partys. DECTs are basically old button cellphones, which allow you to call someone, write messages and that\u0026rsquo;s about it. The main things you want to communicate to others (bars or finances in specific) is to ask for change, that you need helpers or a refill of clean glasses.\nThe problem with talking over DECTs is that because of the music, it\u0026rsquo;s hard to understand each other. The number of DECTs we have available is also limited, which results in only two persons per bar actually having a DECT.\nSo my idea was to create small bar-terminals which can be located in all the cashboxes behind bars at uni-partys to communicate inbetween each other.\nThe terminals are supposed to:\nbe scaleable (as many terminals as you want per bar, as many bars as you want) have predefined messages from which the user can select one and send it to a specific selected bar have a button to send messages to finances have a screen to show messages On top of that, it also would be nice if the send messages to finances could be shown on a website so that finances can open this site on their laptop to read the messages.\nThe last problem is that the wifi-access-point can be overloaded due to the high amount of people (1500) in a small space. Because of this, I decided to use a 433mHz radio signal to communicate between the bars and implement everything as a mesh-network to bridge longer distances between bars.\nTimeline # From the pitch, till the presentation of our project at the \u0026ldquo;Streiflicht\u0026rdquo; at Ulm University we had 7 Weeks (17.05.23 - 05.07.23).\nI set myself the following timeline and milestones:\nFirst two weeks (17.05.23 - 29.05.23):\nResearch on mesh-networks, radio-signals and radio-modules for Arduino, because I barely had any knowledge about any of those topics.\nAs soon as my ordered parts would arrive I planned to put everything together on a breadboard and start programming.\nMilestone 1 till 11.06.23:\nHave a working system on a breadboard\nAfter that, I planned to create housing with the buttons and solder everything together.\nMilestone 2 till 25.06.23:\nFirst version of the project is finished and ready to be presented\nTill 05.07.23:\nImprove small things if necessary\nFirst weeks until the 12.06.23 # Contrary to my timeline I spend more time with researching about mesh networks and radio modules. On top of that, my order of the radio modules got lost as well, which set me back a little.\nIn my pitch, I also got some tips for other ways to communicate between the terminals like using the already existing DECT-Network or LoRaWan, so I researched about them as well and asked a lecturer for further information.\nAs soon as the two radio modules I ordered arrived, I tested both of them about general usability and functionality as well as the range of the radio signal:\nThe NRF24L01-module:\nThe older of the two modules needs 7 pins to connect to an Arduino, uses 2,4 GHz, the range is not that good, there\u0026rsquo;s more documentation on the internet for this one\nHC-12-moduel:\nNewer, needs only 4 pins to connect to an Arduino, uses 433 MHz, range was better in my tests and it seemed more intuitive to use for me.\nSo I decided to use radio modules and choose the HC-12 module over the NRF24L01+PA+LNA-module. The main reasons were longer range, fewer pins to connect, which would make soldering a lot easier later and that it seemed more intuitive to use for me.\nHC-12 NRF24L01+PA+LNA I also ordered rotary encoders and oled-displays to use for the view and control of my terminal.\nUnfortunately, I did not reach the goal of my first milestone, because I just had decided on a radio module.\n12.06. - 20.06 # This week I focused on the view and control of my bar-terminal.\nTo show the user all the necessary information I used a 128x64 pixel oled. For manipulation of the oled like selecting a message, selecting a bar and sending it to that bar I used a rotary encoder.\nI researched a lot about menus with rotary encoders and which library to use to create a menu, but everything I could find surpassed my needs and was extremely complex for just a simple menu so I decided to implement a menu myself. A lot of libraries also nearly filled the ram of an Arduino which was bad if you want to implement more stuff besides the menu.\noled with menue I\u0026rsquo;m pretty proud of the result so I\u0026rsquo;m planning to put it on Instructables or a similar site so other people can use it as well.\nI used the SSD1306Ascii-library made by greiman which is pretty resourceful and not overloaded.\n20.06. - 26.06. # This week I connected my radio modules with the oled and rotary encoder with my menu.\nI basically reached Milestone 1 this week because I had a finished prototype on a breadboard.\nIt was now possible to select a message, a bar that is supposed to receive the message and send the message. The other Terminal then was able to display the Message and from which bar it came.\nWhen a message was sent, every other terminal received it and decided based on the header, if the message was meant for itself or not.\nIf the message was meant for that terminal it displayed the message, otherwise the message got forwarded.\nmessage send message received The header was built out of a string containing 3 numbers:\nThe first number indicated which message was sent. The second number indicated to which terminal the message was supposed to go. The third number indicated from which terminal the message was sent. This week I also organized the inlay of a cash register we use at uni-partys to take to measurements of one of the compartments which are supposed to hold the box of my terminal. I also decided to add a LED to the Terminal, which indicates if a message is received.\nAfter this week I planned to finish milestone 2 but I only soldered one of the three terminals and the housing of the terminals was not yet printed.\n26.06. - 03.07. # This week I designed the housing of my terminals, made a test print if the housing would fit into the cash-register inlay. I also made a test print for the cover of my housing, to see if my measurements for the led, antenna of the radio-module, oled-screen and rotary encoder would fit.\nAt last, I soldered the other two terminals and made some improvements in the code.\ncover of my housing week of presentation until the 05.07.23 # In the last few days, I finished printing the housings and covers for them. I wanted to print a second revision for the covers unfortunately, the printer stopped working so I had to go with my first version in the presentation.\nStreiflicht on 05.07 # At the Streiflicht the whole SwH group had a room in which we presented our projects to interested guests. There were also pretty interesting lectures. I really enjoyed the streiflicht and the interaction with interested people in my project was good. We discussed further improvements and the hardware I used for my project.\nposter streiflicht Conclusion: # I was able to implement the key part of my project, the Terminal and being able to communicate between bars.\nUnfortunately, there was not enough time to also add a webpage for finances, so that they can receive the messages via their laptop. On the other hand, they can also just use a terminal to receive messages which works fine as well. The idea for the webpage would have been to use a wemos d1 mini microcontroller to receive radio signals and log into wifi to submit the information to the webpage.\nAnother idea was to build a Button myself by using a compliant mechanism, but I also did not have enough time for that.\nI spontaneously added an LED to show if something was received which is pretty helpful for usability in my opinion.\nTools and methods # Compared to my exercise project this project was more on the software side, than the hardware side. In my opinion, that was pretty good because I\u0026rsquo;d say my weakness is more in programming than building stuff. In general, I would say I prefer production with a 3D-printer, and laser-cutting as well as the mechanics part of it, like making the steering system for my exercise project more than programming, but through this project programming also got more interesting.\nFor programming I used visual-studio-code with platform.io, an Arduino extension, which is way better than the standard Arduino IDE. I really enjoyed working with it, because managing libraries is a lot easier. Working with more than one Arduino (3 terminals) at the same time is also better, because you can specify upload ports. Syntax highlighting is another big plus for platform.io.\nTo produce the housing and cover for it I only worked with 3D-printers. In the end, one printer stopped working, which was unlucky but other than that I had no problems and really enjoyed working with all the printers in the lab.\nTo attach the LED, oled-screen and radio-module to the cover I used hot glue which didn\u0026rsquo;t cause any problems either. The rotary encoder got attached by the included screw.\nFor soldering, I used the soldering-irons in the lab and my soldering-iron at home and the band saw in the lab to cut the breadboards to size. With the tools in the lab, I did not have any problems. For the soldering-iron at home, of which the temperature can\u0026rsquo;t be adjusted, I learned that pointy soldering tips are bad compared to tips with a wide tip because the heat gets distributed differently.\nMotivation and feedback for future semesters # I think most of my motivation for the module came from my existing interests in microcontrollers and building stuff (from Lego models to the desk for my pc with screen holders and built-in buttons). The lab with all the accessible tools, machines and other useful stuff was another big motivation because the possibilities get a lot bigger than with the tools I have at home. At last, our main lecturer and also the other lecturers motivated me because if I had questions or problems they always could help me and in general had a lot of helpful input.\nI think for the future I generally gained a deeper knowledge about working with microcontrollers, 3D-printers, laser cutters and about the possibilities that you have with those tools, also the projects of fellow students helped with getting inspirations for future projects I want to do myself.\nThe two main things I learned through my project for the second semester are that even something that seems impossible, because of missing knowledge about the topic and resulting in the inability to assess if you will manage to do the project, it is still possible. When pitching the project I was very insecure about the possibility of me finishing the project, but in the end, it worked and I learned a lot of new interesting stuff about microcontrollers, radio-signals and -modules. For the first time, I also understood the basics of Networks which definitely will help me a lot for my further informatics studies.\nIn general, I am happy with how the module is structured and I also think the topics we got introduced to were helpful. The only thing I would recommend for future semesters would be more time for the main project in the second semester. Maybe pitch the project at the end of the first semester so that you have the whole lecture free time and the summer semester for the project. The last thing I would note is, that it was quite hard to find a project that solves a problem or is unique because these days you can find almost everything on the internet. I think maybe just a new approach to an already existing project is also challenging enough because I spend a lot of time thinking about a real problem I want to solve that isn\u0026rsquo;t already solved.\nFinal Project # Summary of my plan # My initial idea was to create something that allows bars to communicate with finances to signalize them when they need a refill of change or when the cash registers are getting to full and need to be emptied.\nOut of this came the project of creating bar terminals, that allow the bars at uni-partys to communicate with each other by sending and being able to receive predefined messages.\nFinal status of my project - features # Features in short: # Size fitting to the inlays of cash registers so that they can be placed securely behind a bar. Oled-screen to show the menu to select messages to be sent and to show received messages LED to better highlight if a message has been received received message Rotary encoder to use the menu shown on the screen, select a message, a bar for which the message is meant and finally send it. rotary encoder Power is supplied by a 9V-Battery so there is no need for an external power source Features explained # The \u0026ldquo;brain\u0026rdquo; of the bar-terminal is an Arduino nano, basically a mini-cpu. Connected to the Arduino is a screen as a view for the user, a rotary encoder as a controller, a LED as another indicator for the user as well a radio module to send and receive messages.\nMenue on the oled-screen with rotary encoder and LED:\nThe terminal can be controlled by a user by using the rotary-encoder. The user can see his or her manipulations by the rotary-encoder on the oled-screen.\nStandard the oled screen shows a main-screen of my implemented menu.\nmain menu By pressing the rotary encoder the oled shows the screen which shows all the predefined messages for the user to select one.\nmessage menu The message can be selected by turning the rotary encoder in either direction. A selected message is marked with this symbol: \u0026ldquo;\u0026gt;\u0026rdquo;.\nThere is also an option for the user to return out of the message-selection-screen back to the start screen.\nback option As said, a message is selected by the \u0026ldquo;\u0026gt;\u0026quot;-symbol. To continue with selecting a bar the user has to press the rotary encoder again.\nThe next screen, to select a bar to which the message is supposed to be sent, is quite similar to the screen for selecting a message.\nbar menu Again, a bar is selected by turning the rotary encoder in either direction and by pressing the rotary encoder the message selected by the \u0026ldquo;\u0026gt;\u0026quot;-symbol gets sent.\nAfter sending the message you automatically return to the main screen which informs the user that the message has been sent.\nmessage send A terminal can only receive a message if the main-screen is active. That means that while selecting a message and bar, the terminal can\u0026rsquo;t receive messages.\nIf a message is received the LED turns on and the message gets displayed on the main menu.\nmessage received The LED can be turned of by pressing the rotary encoder once, then also the received message disappears.\nSending and receiving messages:\nSending and receiving messages works because of the radio-module.\nIt communicates over 433mHz radio signals with the other radio-modules in other terminals.\nThis allows the terminals to work completely independently. This is useful on partys because the wifi access-point as well as mobile networks are often overloaded.\nSending and receiving are implemented as a simplified \u0026ldquo;mesh-network\u0026rdquo;. This means that if a terminal sends a message every terminal in signal reach will receive the message.\nThe message consists of four letters that are numbers:\nFirst number: Indicates to which terminal the message is supposed to be sent Second number: Indicates from which terminal the message has been sent Third number: Indicates which message has been sent Fourth number: To help prevent loops caused by forwarding aka \u0026ldquo;forwarding-bit\u0026rdquo; If a terminal receives a message, it first checks if the message is meant for this terminal by reading the first number, if the number matches the number of this terminal it will display the message on the oled-screen and turn on the LED.\nIf the message is not meant for this terminal, the message gets forwarded and the last number is saved so that the message can\u0026rsquo;t be forwarded again. Forwarding basically just means that the message gets resend to every terminal in range, a terminal forwards a message just once.\nForwarding allows to \u0026ldquo;bridge\u0026rdquo; between two or more terminals which increases the distance between terminals over the possible range of the radio signal.\nTODO-VIDEO\nImprovements # The only function that worked not as well on my presentation on streiflicht was that forwarding sometimes created loops. I thought I had solved it but there still were some errors, but they now should be fixed.\nOther than that everything worked out as I hoped, but there are still a lot of possible improvements:\nSwitch to turn off the battery If a message is received, the length of the message can be checked to see if the message was received completely. with this feature included an acknowledgment message that gets sent back to the original sender of the message would be useful.\nThis allows to signalize the sender of a message if the message has been received or not or if the message is too short. This way the sender could resend the message if necessary because right now the sender assumes that the message will be received and if not the message is just lost.\nI also thought of a wifi integration that allows for instance finances to receive the messages that are meant for them over a website. The reason for this is that finances on uni-partys are located in a room further away from the party ground and able to use laptops because the laptops are not as exposed to damage as behind a bar. ","date":"18 July 2023","permalink":"/swh/posts/project-second-semester/","section":"Posts","summary":"Project pitch # We started the second semester with a presentation about the pitch of the project we planned to tackle for the second semester.\nThe Problem I wanted to solve is communication between bars and finances at Uni-Partys.","title":"Project Second Semester"},{"content":" Presentation # We had a small fair to present our projects. Everyone of us got a small space at a table with our posters behind it to present our project to interested people that were invited.\nEveryone who came to my project was really interested and asked detailed questions about it, which made the overall presentation pretty enjoyable.\nI remember the following questions:\nDid I designed everything (laser-cutted and 3D-printed parts) for the project myself?\nYes I did.\nDid I use bluetooth or wifi to controll the car?\nBluetooth.\nDid I programm the bluetooth app myself?\nNo I did not.\nWhat was the most challenging part of my project?\nDefinitely designing the steering mechanism. It involved a lot of measuring and several tries to print all the interlocking parts.\nWhat the various electronic components in my project are responsible for.\nESP32 development board as a microcontorller Servo for stearing DC-motor for acceleration Two 9V blocks for power Voltage converter to get the 9V down to 5V for the microcontroller Motor driver to controll the DC-motor How many motors did I use?\nTwo (Servo for steering and DC-motor for acceleration).\nIn general the feedback to my project was really positive and with some visitors I talked about further improvements I wanted to add to the car, like lights for example.\nReview of the semester # Looking back over the first semester of sketching with hardware I had a lot of fun in this module. I learned a lot of new things like mainly 3D-printing and laser-cutting and also gained a lot of experince in those two manufacturing preocesses through the exercise project.\nIn the fields electrical engineering, microcontrollers and mechanics, I already had a lot of knowledge beforehand but still learned some new things that were pretty interesting.\nI think it would be pretty good to learn about the differnt manufacturing processes like 3D-printing and laser cutting a little earlier in the semester. That way it would be possible to start working on the exercise project earlier because for my project 3D-printing and laser-cutting needed the most time and intersected a little with my exam phase.\nProgress over the semester # In the beginning of the Semester we had to make a presentation about a DIY project which we thought would be interesting.\nI took a project from Stuff Made Here:\nI wrote the following about, if I could do the project:\nI think after this semester I definitely gained a lot of experience so that this project is even easier to implement.\nNow I know how to use a 3D-printer, so the manufacturing process should be a lot easier then before the semester. My exercise project didn\u0026rsquo;t involved a lot of programming so that still would be a challenge but I also communicated with a apple device so there is a little progress as well.\nNext semester # I am really looking forward to the next semester and working on a bigger project with also a lot more time for it.\nI don\u0026rsquo;t really know yet what my project for the second semester will be but I think an autonomous driving car, or a app with which I can controll all the lights of my lego models would be interesting to make. Another cool project would be to motorise the manual function of height adjusting my desk which would be controlled via wifi over a website to safe different prefered heights, etc.\n","date":"28 February 2023","permalink":"/swh/posts/exercise-project/","section":"Posts","summary":"Presentation # We had a small fair to present our projects. Everyone of us got a small space at a table with our posters behind it to present our project to interested people that were invited.","title":"Exercise Project"},{"content":"In the lecture part we first got introduced to the different types of 3D-printers namely SLA-, FDM-, SLS- and SPD-printers.\nThe process to a finished print generally starts from an idea and measures which is followed by 3D-modeling, the finished model then gets exported as a mesh, after that sliced to GCode which 3D-printers understand. GCode basically is the model sliced into a lot of layers which when printed ontop of each other build the model again.\nFused Deposition Modeling (FDM) # FDM-printing is the cheapest way of 3D printing and this more common used in a private environment. The quality and details of this type of printer is badder compared to other types of printers. It works heating up Filament and depositting it through a nozzle onto a print-bed.\nUltimaker 2+ (Left), Snapmaker original (right) Ultimaker 2+ printing Finished print on the snapmaker original Stereolithography (SLA) and Digital Light Procressing (DLP) # SLA-printing uses a laser and a specific liquid (resin) to create 3D-structures. The Laser hits and because of that hardens the liquid only on the spots where a structure is supposed to be. This gets repeated layer for layer.\nDLP-printing works similary to SLA-printing.\nSelective Laser Sintering (SLS) # For SLS-printing a powder is used which then gets hardend by a laser. It has pretty good mechanical properties and because of the powder no support structures for overhangs are needed. Unfortunately it only available for industry.\nSelective Powder Deposition (SPD) # SPD-printing works similary to SLS-printing, its also possible to print metals. Currently not very common.\nCAD- vs. mesh-software # Mesh-software should only be used to create 3D-models for organic sturctures like figurines because it does not offer the best dimensional accuracy. With CAD-software on the other hand it is possible to create accurately measured 3D-models which is usefull if you need parts specifically sized.\nLab # In the MI-Lab we have the following devices avilable:\nCreality CR10 S5 with a 500 mm x 500 mm print-bed ELEGOO MARS 2 Pro which is a SLA-printer Snapmaker Original which is capable of printing, cnc-milling as well as laser engraving Ultimaker Original and Ultimaker 2+ For slicing Ultimaker Original, Ultimaker 2+ as well as Creality CR10 S5 need Cura. The printer Snapmaker Original needs Snapmaker Luban for slicing and ELEGOO MARS 2 Pro needs Chitubox.\nWhen creating 3D-models there is a variety of software available, for example Solidworks and Sketchup which are used by a lot of people, I personally really like to use Autodesk Fusion 360. If you want to create more natural and shapes like figuriens Blender is a popular option to use.\nProblems while printing: # When printing a lot of problems can occur, I personally experienced a clogged nozzle, warping and bad overhangs.\nMy print with bad overhang in the hole My print in which you can see that the nozzle was clogged while printing the bottom part. ","date":"25 February 2023","permalink":"/swh/posts/additive-manufacturing/","section":"Posts","summary":"In the lecture part we first got introduced to the different types of 3D-printers namely SLA-, FDM-, SLS- and SPD-printers.\nThe process to a finished print generally starts from an idea and measures which is followed by 3D-modeling, the finished model then gets exported as a mesh, after that sliced to GCode which 3D-printers understand.","title":"Additive Manufacturing"},{"content":"In the lecture part of subtractive manufacturing we first learned about vector graphics as well as G-Code which is used in a lot of computer guided machines like laser cutters, 3D-printers, etc.\nThen we got an overview of tools to create svg\u0026rsquo;s as well as 3D-models.\nNext we learned about CNC milling and the basics about how it works. We got an introduction into CNC mill bits and learned about problems you have to face with a CNC mill for exampel that it is impossible to make really small sharp inner corners because a mill bit is always round and that the thinness of a wall is limited due to vibration during milling.\nAfter CNC milling we got an introduction to laser cutting and the laser cutter we have in our lab. With a laser-cutter it is possible to cut, engrave as well as mark material. When cutting like it is when sawing wood, material gets removed, which has to be calculated when creating a sketch you want to cut. When designing its usefull tu creat interlocking parts in order to make the final object more stable, its also possible to design bending structures for some really interesting shapes.\nSource: https://www.instructables.com/Curved-laser-bent-wood/\nLastly we learned about safety when working with laser-cutters as well as CNC-mills.\nFor laser-cutters it is important to only use materials which you can find in the manual of the cutter (in our case Emblaser 2). All other materials should not be used to be cut by the laser-cutter especially if you are not sure which material you have infornt of you.\nLab # In the Lab part we then made our first-hand experiences with laser cutting.\nSketching # First we had to sketch our project and parts of it we could potentially cut/make with a laser-cutter.\nSketch 1\nMy plan is to build a rc-car, and the body of it I want to build out of laser-cutted pieces. The car is inspired by a Landrover Defender.\nThe the sketch in the top left corner consists of two pieces which overlapp in order to better glue them together.\nIn the bottom right corner you can see the same two pieces as in the top left corner with a system to connect them even more stable together.\nSketch 2\nHere you can see the second part of my sketch which includes the chassis of my car with some tries on the steering system, everything you can see here has to be 3D-printed.\nCreating a svg # After sketching we went to a tool of our choice, in my case Affinity Designer and designed a small maximum 5x5cm svg to cut with the laser cutter.\nI choosed the top siede-part of my car-body with the windows:\nThe two notches on the bottom are there to connect the part more secure and a test on how thick I have to make a notch in order to interlock it with other parts. The thickness of the material is 3 mm, I went with a notch 2,8 mm wide which worked out perfectly in the end.\nLaser Cutting and Final Part # The final svg then can be loaded into LightBurn.\nIt is important to choose which cuts have to be made first, in my case the windows, because if you cut the outer edge first the whole part would be loose and could slip while cutting the windows. The reason for this is that there is a ventilation system in the Laser-Cutter which vibrates a little.\nHere you can see the cutted piece slotted into the two inner window pieces.\nIn LighBurn its also important to choose the settings for cutting a certain material.\nIn this case we used the preset for our material and modivied it so that the laser makes 3 rounds and also moves down around 1 mm after each round of cutting.\n","date":"28 January 2023","permalink":"/swh/posts/subtractive-manufacturing/","section":"Posts","summary":"In the lecture part of subtractive manufacturing we first learned about vector graphics as well as G-Code which is used in a lot of computer guided machines like laser cutters, 3D-printers, etc.","title":"Subtractive Manufacturing"},{"content":"In the lecture part of mechanics we learnd a little bit about the physical basics and some important formulas regarding them. We got introduced to levers, pulleys, wheels and axles as well as screws and gears. After that the basic functionality of motors got explained and how a dc-motor transforms electrial energy into a rotation. Servo motors and stepper-motors were presented as well. In the robotics part we learned about different kinds of linkages and the resulting kinematics out of linkages. In the end we got introduced to the concept of soft robotics inspired by nature and how to unterstand mechanisms.\nLab # In the lab part we then explored some mechanisms with a \u0026ldquo;Fischertechnik-Baukasten\u0026rdquo;.\nPush crank # First we build a push crank, which transforms a rotational motion into a linear motion. In the other direction this is used in a bike with the pedals transforming linear motion into a rotation.\nManual gearbox with 3 gears # After the push crank we had to build a manual gearbox with 3 gears.\nIn the picture below you can see the 3 different gears and the reverse gear.\nThe gears get switched by putting the lever which you can see the best in picture 4 in different positions.\nThe crank in the top left corner is used to drive the gearbox\nThe small gearwheel drives the bigger one, which results in a slower speed. Two same sized gearwheels are used, the speed stays the same and isn\u0026rsquo;t translated. A big gearwheel drives a smaller one, which results in a higher speed. A third gear is added which results in reversing the direction in which the wheel spins and equals a reverse gear. Differential gear # A differential gear is used to equalize the speed between two parallel tires. This happens when a car drives a curve, because then the inner tire will cover a smaller distance than the outer tire because the radius is smaller.\nPlanetary gear # A planetary gear is basically used like a gearbox and translates speeds as well. You can find it for example in a hub transmission in a bike or to gear vehicles like tractors additionally down.\n","date":"26 January 2023","permalink":"/swh/posts/mechanics/","section":"Posts","summary":"In the lecture part of mechanics we learnd a little bit about the physical basics and some important formulas regarding them. We got introduced to levers, pulleys, wheels and axles as well as screws and gears.","title":"Mechanics"},{"content":"In the lecture parts of microcontrollers we got introduced to the Arduino-Ecosystem of boards and shields. Then we learned about board features, as well as the Arduino IDE and the basics of Serial Communication. I think learning a little about wifi in context with arduino would be interesting, as well as introducing the \u0026ldquo;millis()\u0026rdquo; function instead of \u0026ldquo;delay()\u0026rdquo; because it\u0026rsquo;s really powerful function if you understand it.\nLab # In the lab part we then experimented hands-on with microcontrollers and different sensors, to get a feeling for everything.\nWeek 1: Controlling LEDs with a Hall-Sensor and a LDR-Sensor, PlatformIO # In the first lab I tried some different sensors by controlling the LED-state with them and switched from the Arduino IDE to PlatformIO, a Visual Studio Code extension for working with Arduino, as well as ESP-Boards.\nHall- and LDR-Sensor:\nA Hall-Sensor reacts to a magnetic field which then can be read by a microcontroller. The LDR-Sensor works similar only that it reacts to a change of brightness instead to a magnetic field.\nCircuit:\nResistors for the LEDs: 220 ohm Resistor for the Hall-Sensor: 10k ohm\nCode:\n#define PIN_HALL_SENSOR 14 //Hall-Sensor #define PIN_LED1 12 #define PIN_PHOTO_RESISTOR A0 //LDR-Sensor #define PIN_LED2 13 int brightness = 0; void setup() { pinMode(PIN_HALL_SENSOR, INPUT); pinMode(PIN_LED1, OUTPUT); pinMode(PIN_LED2, OUTPUT); Serial.begin(9600); } void loop() { //Set LED to read value of LDR-Sensor digitalWrite(PIN_LED1, digitalRead(PIN_HALL_SENSOR)); brightness = analogRead(PIN_PHOTO_RESISTOR); Serial.println(\u0026#34;Hall: \u0026#34;); Serial.println(digitalRead(PIN_HALL_SENSOR)); Serial.println(\u0026#34;LDR: \u0026#34;); Serial.println(brightness); if (brightness \u0026lt; 600) { digitalWrite(PIN_LED2, HIGH); } else { digitalWrite(PIN_LED2, LOW); } } Magnet on Hall-Sensor (LED1 is turned off), LDR-Sensor in room-light (LED2 is turned off). Hall-Sensor without magnet (LED1 is turned on), LDR-Sensor covered (LED2 is turned on) Week 2: Wifi, Servo-Motor controlled via the Blynk-App # First I turned on and off a LED over WIFI with a D1 Mini and after that I tried the Blynk App to control a servo over my phone, you can see the code below.\nCode:\n#define BLYNK_TEMPLATE_ID \u0026#34;xxx\u0026#34; #define BLYNK_DEVICE_NAME \u0026#34;xxx\u0026#34; #define BLYNK_AUTH_TOKEN \u0026#34;xxx\u0026#34; #define BLYNK_PRINT Serial #include \u0026lt;ESP8266WiFi.h\u0026gt; #include \u0026lt;BlynkSimpleEsp8266.h\u0026gt; #include \u0026lt;Servo.h\u0026gt; Servo servo1; char auth[] = BLYNK_AUTH_TOKEN; // Your WiFi credentials. // Set password to \u0026#34;\u0026#34; for open networks. char ssid[] = \u0026#34;\u0026#34;; char pass[] = \u0026#34;\u0026#34;; BlynkTimer timer; // This function is called every time the Virtual Pin 0 state changes BLYNK_WRITE(V0) { // Set incoming value from pin V0 to a variable int value = param.asInt(); Serial.println(value); if (value == 1) { servo1.write(-90); } else { servo1.write(90); } // Update state Blynk.virtualWrite(V1, value); } // This function is called every time the device is connected to the Blynk.Cloud BLYNK_CONNECTED() { // Change Web Link Button message to \u0026#34;Congratulations!\u0026#34; Blynk.setProperty(V3, \u0026#34;offImageUrl\u0026#34;, \u0026#34;https://static-image.nyc3.cdn.digitaloceanspaces.com/general/fte/congratulations.png\u0026#34;); Blynk.setProperty(V3, \u0026#34;onImageUrl\u0026#34;, \u0026#34;https://static-image.nyc3.cdn.digitaloceanspaces.com/general/fte/congratulations_pressed.png\u0026#34;); Blynk.setProperty(V3, \u0026#34;url\u0026#34;, \u0026#34;https://docs.blynk.io/en/getting-started/what-do-i-need-to-blynk/how-quickstart-device-was-made\u0026#34;); } // This function sends Arduino\u0026#39;s uptime every second to Virtual Pin 2. void myTimerEvent() { // You can send any value at any time. // Please don\u0026#39;t send more that 10 values per second. Blynk.virtualWrite(V2, millis() / 1000); } void setup() { // Debug console servo1.attach(D6); Serial.begin(9600); Blynk.begin(auth, ssid, pass); // You can also specify server: //Blynk.begin(auth, ssid, pass, \u0026#34;blynk.cloud\u0026#34;, 80); //Blynk.begin(auth, ssid, pass, IPAddress(192,168,1,100), 8080); // Setup a function to be called every second timer.setInterval(1000L, myTimerEvent); } void loop() { Blynk.run(); timer.run(); // You can inject your own code or combine it with other sketches. // Check other examples on how to communicate with Blynk. Remember // to avoid delay() function! } Here you can see the circuit:\nWeek 3: External Interrupt # In this week I tried external Interrupts, they are helpfull to monitor (user-)input and react to them. The Interrupt Service Routine (ISR) is a callback function with 4 modes:\nLow: Interrupt is triggered if pin is low Change: Interrupt is triggered if pin state changes Rising: Interrupt is triggered if pin switches from low to high Falling: Interrupt is triggered if pin switches from high to low High: Interrupt is triggered if pin is high My idea of using external interrupts was to have two LEDs, of whom one is green and shows that everything works OK and the other one is red and starts blinking if there is a problem. In my case the \u0026ldquo;problem\u0026rdquo; gets triggered by a button, after which the green LED turns of and the red one start blinking. If the button gets pressed again the problem is \u0026ldquo;solved\u0026rdquo;, the red LED truns off and the green one is on again.\nHere you can see the code, I used the \u0026ldquo;change\u0026rdquo;- mode for the ISR:\nconst int ledPin1 = 12; //Grüne LED const int ledPin2 = 11; //Rote LED const int buttonPin = 2; //Interrupt Button int x=0, y=0; //Variablen zum Hochzählen int ledToggle1 = HIGH; //Zustand Grüne LED int ledToggle2 = LOW; // Zustand Rote LED für Interrupt //Variablen um timing der Interrupts festzustellen unsigned long button_time = 0; unsigned long last_button_time = 0; int ledState = LOW; //Zustand Rote LED für Blinken //Variable zum Blinken der Roten LED unsigned long previousMillis = 0; const long interval = 250; //Blink delay der Roten LED void button_ISR(){ button_time = millis(); //check to see if increment() was called in the last 250 milliseconds if (button_time - last_button_time \u0026gt; 250){ Serial.print(\u0026#34;Interrupt \u0026#34;); Serial.print(y++); Serial.println(); ledToggle1 = !ledToggle1; digitalWrite(ledPin1, ledToggle1); ledToggle2 = !ledToggle2; digitalWrite(ledPin2, ledToggle2); last_button_time = button_time; } } void setup() { pinMode(ledPin1, OUTPUT); pinMode(ledPin2, OUTPUT); pinMode(buttonPin, INPUT_PULLUP); Serial.begin(9600); attachInterrupt(digitalPinToInterrupt(buttonPin), button_ISR, CHANGE); digitalWrite(ledPin1, HIGH); } void loop(){ Serial.print(\u0026#34;loop \u0026#34; ); Serial.print(x++ ); Serial.println(); unsigned long currentMillis = millis(); if (y%2==1){ if (currentMillis - previousMillis \u0026gt;= interval) { // save the last time you blinked the LED previousMillis = currentMillis; // if the LED is off turn it on and vice-versa: if (ledState == LOW) { ledState = HIGH; } else { ledState = LOW; } // set the LED with the ledState of the variable: digitalWrite(ledPin2, ledState); } } } Circuit:\nHere you can see everything in action:\n","date":"6 December 2022","permalink":"/swh/posts/microcontroller/","section":"Posts","summary":"In the lecture parts of microcontrollers we got introduced to the Arduino-Ecosystem of boards and shields. Then we learned about board features, as well as the Arduino IDE and the basics of Serial Communication.","title":"Microcontroller"},{"content":"In the lecture part of the electrical engineering-lab we learned about the basic formulas and units of electrical engineering, how to use resistors and got introduced to some basic circuits like series- and parallel-circuits. We also got introduced in a lot of components which we might need later in our projects.\nLab # In the lab part we then put some of the principles we learned to practise.\nSoldering # First we soldered some components which was nothing new to me but still entertaning since my soldering-iron at home isn\u0026rsquo;t that advanced.\nThe row on the left and the two pins at the bottom are my soldering result.\nCircuit with voltag and current measurement # Next we built a small circuit and measured the voltage and current on it to calculate and plot the value of the resistor we used while changing the voltage.\nAs you can see in the picture above we accidentally burned a resistor.\nThe circuit was the following:\nVoltage is measured in parallel Current is measured in series In this picture you can see the multimeter measuring the current in series as well as the power supply in the back. Unfortunately we firstly plugged the multimeter wrong as you can see in the picture, we later realised it because we got wrong numbers in our plot of the resistance.\nThis part was nothing new for me either because i had electrical engineering in school for 3 years and also measure stuff at home for own projects.\nProject # I chose the project \u0026ldquo;rc-car\u0026rdquo; since I like to build rc-cars out of lego technic in my free time, I figured it would be an interesting challenge to built a car even more from scratch than with lego.\nIn the picture below you can see my first try on a circuit for a simple rc-car with left- and right-indicators.\nServo for steering DC-motor for acceleration (the circuit enables forward and backward driving as well as pwm control) 2 times 2 LEDs in series for the left- and the right-indicator Bluetooth-module for rc control via a phone ","date":"15 November 2022","permalink":"/swh/posts/electrical-engineering/","section":"Posts","summary":"In the lecture part of the electrical engineering-lab we learned about the basic formulas and units of electrical engineering, how to use resistors and got introduced to some basic circuits like series- and parallel-circuits.","title":"Electrical Engineering"},{"content":"Hey, I\u0026rsquo;m Jakob!\nI study Media Informatics at Ulm University in my 5th semester (at the time of this post). In my free time I like to do sports, build stuff out of wood and design my own Lego Technic RC-Cars.\nBy attending this subject I hope to extend my knowledge about microcontrollers and modeling in 3D. Furthermore I\u0026rsquo;m looking forward to learn how to use a 3D-Printer, CNC and a Laser-Cutter for the first time.\nI chose this subject because I\u0026rsquo;m generally interested building DIY stuff and for school I did a microcontroller-project in which i tried to build a RC-Car with automatic differential-locks. The car worked more or less and with this subject I hope to clear some difficulties I faced in this project.\nIf I had all the tools and abilitys I need, I would like to build a reciever to start my PC over my phone and a button build Into my desk which turns on my power strip via a relay as well as my PC simultaneously. All the stuff could be hidden underneath my small shelf on which my screens are standing behind a laser-cutted IO-shield\n","date":"5 November 2022","permalink":"/swh/posts/introduction/","section":"Posts","summary":"Hey, I\u0026rsquo;m Jakob!\nI study Media Informatics at Ulm University in my 5th semester (at the time of this post). In my free time I like to do sports, build stuff out of wood and design my own Lego Technic RC-Cars.","title":"First Post - Introduction"},{"content":"","date":"1 January 0001","permalink":"/swh/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/swh/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 January 0001","permalink":"/swh/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"1 January 0001","permalink":"/swh/tags/","section":"Tags","summary":"","title":"Tags"}]